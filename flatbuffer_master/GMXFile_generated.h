// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_GMXFILE_DEADCREATOR_H_
#define FLATBUFFERS_GENERATED_GMXFILE_DEADCREATOR_H_

#include "flatbuffers/flatbuffers.h"

namespace DeadCreator {

struct Vector2;

struct Coord;

struct Size;

struct TileInfo;

struct GMXFile;

enum TileType {
  TileType_Dirt = 0,
  TileType_Grass = 1,
  TileType_Water = 2,
  TileType_Hill = 3,
  TileType_MIN = TileType_Dirt,
  TileType_MAX = TileType_Hill
};

inline const char **EnumNamesTileType() {
  static const char *names[] = { "Dirt", "Grass", "Water", "Hill", nullptr };
  return names;
}

inline const char *EnumNameTileType(TileType e) { return EnumNamesTileType()[static_cast<int>(e)]; }

MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vector2, 8);

MANUALLY_ALIGNED_STRUCT(4) Coord FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Coord(int32_t _x, int32_t _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  int32_t y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Coord, 8);

MANUALLY_ALIGNED_STRUCT(4) Size FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t width_;
  int32_t height_;

 public:
  Size(int32_t _width, int32_t _height)
    : width_(flatbuffers::EndianScalar(_width)), height_(flatbuffers::EndianScalar(_height)) { }

  int32_t width() const { return flatbuffers::EndianScalar(width_); }
  int32_t height() const { return flatbuffers::EndianScalar(height_); }
};
STRUCT_END(Size, 8);

struct TileInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUMBER = 4,
    VT_INDICES = 6
  };
  const flatbuffers::String *number() const { return GetPointer<const flatbuffers::String *>(VT_NUMBER); }
  const Coord *indices() const { return GetStruct<const Coord *>(VT_INDICES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NUMBER) &&
           verifier.Verify(number()) &&
           VerifyField<Coord>(verifier, VT_INDICES) &&
           verifier.EndTable();
  }
};

struct TileInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_number(flatbuffers::Offset<flatbuffers::String> number) { fbb_.AddOffset(TileInfo::VT_NUMBER, number); }
  void add_indices(const Coord *indices) { fbb_.AddStruct(TileInfo::VT_INDICES, indices); }
  TileInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileInfoBuilder &operator=(const TileInfoBuilder &);
  flatbuffers::Offset<TileInfo> Finish() {
    auto o = flatbuffers::Offset<TileInfo>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<TileInfo> CreateTileInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> number = 0,
   const Coord *indices = 0) {
  TileInfoBuilder builder_(_fbb);
  builder_.add_indices(indices);
  builder_.add_number(number);
  return builder_.Finish();
}

struct GMXFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEFAULT_TYPE = 4,
    VT_TILES = 6,
    VT_NUMBER_OF_TILES = 8,
    VT_TILE_SIZE = 10
  };
  TileType default_type() const { return static_cast<TileType>(GetField<int32_t>(VT_DEFAULT_TYPE, 0)); }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *tiles() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_TILES); }
  const Coord *number_of_tiles() const { return GetStruct<const Coord *>(VT_NUMBER_OF_TILES); }
  const Size *tile_size() const { return GetStruct<const Size *>(VT_TILE_SIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEFAULT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TILES) &&
           verifier.Verify(tiles()) &&
           verifier.VerifyVectorOfTables(tiles()) &&
           VerifyField<Coord>(verifier, VT_NUMBER_OF_TILES) &&
           VerifyField<Size>(verifier, VT_TILE_SIZE) &&
           verifier.EndTable();
  }
};

struct GMXFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_default_type(TileType default_type) { fbb_.AddElement<int32_t>(GMXFile::VT_DEFAULT_TYPE, static_cast<int32_t>(default_type), 0); }
  void add_tiles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> tiles) { fbb_.AddOffset(GMXFile::VT_TILES, tiles); }
  void add_number_of_tiles(const Coord *number_of_tiles) { fbb_.AddStruct(GMXFile::VT_NUMBER_OF_TILES, number_of_tiles); }
  void add_tile_size(const Size *tile_size) { fbb_.AddStruct(GMXFile::VT_TILE_SIZE, tile_size); }
  GMXFileBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GMXFileBuilder &operator=(const GMXFileBuilder &);
  flatbuffers::Offset<GMXFile> Finish() {
    auto o = flatbuffers::Offset<GMXFile>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<GMXFile> CreateGMXFile(flatbuffers::FlatBufferBuilder &_fbb,
   TileType default_type = TileType_Dirt,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> tiles = 0,
   const Coord *number_of_tiles = 0,
   const Size *tile_size = 0) {
  GMXFileBuilder builder_(_fbb);
  builder_.add_tile_size(tile_size);
  builder_.add_number_of_tiles(number_of_tiles);
  builder_.add_tiles(tiles);
  builder_.add_default_type(default_type);
  return builder_.Finish();
}

inline const DeadCreator::GMXFile *GetGMXFile(const void *buf) { return flatbuffers::GetRoot<DeadCreator::GMXFile>(buf); }

inline bool VerifyGMXFileBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<DeadCreator::GMXFile>(); }

inline void FinishGMXFileBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<DeadCreator::GMXFile> root) { fbb.Finish(root); }

}  // namespace DeadCreator

#endif  // FLATBUFFERS_GENERATED_GMXFILE_DEADCREATOR_H_
